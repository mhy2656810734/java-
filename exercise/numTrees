class Solution {
    public int numTrees(int n) {
        // 分析题意
        // 节点个数为n的时候，共有多少种二叉搜索树
        // 假设n等于5 以3为根节点  3的左子树2个节点 右子树两个节点
        // 那么子问题就是求3的左子树的节点个数为2的时候，共有多少种二叉搜索树
        //             求3的右子树的节点个数为2的时候，共有多少种二叉搜索树
        // 1.状态表示
        // dp[i] 表示节点个数为i的时候，共有多少种二叉搜索树
        // 2.状态转移方程
        // 假设节点个数为i
        // 当根节点为j时(1 <= j <=i)，左子树节点编号: 1~j-1  右子树节点编号:j+1 ~ i
        //               左子树节点个数: j-1      右子树节点个数:i-j
        // 此时，二叉搜索树的个数就是 j-1 * i-1 (因为左边选一个节点，右边对应选一个，总选法就是相乘)
        // 因此，当根节点为j时，二叉搜索树的个数就是dp[j-1]*dp[i-j]
        // 由于j是一个变化的范围，因此状态转移方程就是
        // dp[i] += dp[j-1]*dp[i-j]
        // 3.初始化
        // 0位置可能越界，需要初始化, dp[0] = 1,表示根节点为0的时候，空集也算一个二叉搜索树
        // 主要是为了后面填表，如果为0的话都是0
        // 4.填表顺序
        // 从左到右
        // 5.返回值
        // dp[n]

        // 创建dp表
        int[] dp = new int[n+1];
        // 初始化
        dp[0] = 1;
        // 填表
        for (int i = 1; i <= n;i++) {
            // 枚举根节点
            for (int j = 1; j <= i;j++) {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        // 返回值
        return dp[n];

    }
}
