class Solution {
    public int getMaxLen(int[] nums) {
        // 由于数组中的数有正负，所以无法单独使用一个状态表示
        // 1.状态表示
        // f[i] 表示以i位置结尾的所有子数组中乘积为正数的最长子数组长度
        // g[i] 表示以i位置结尾的所有子数组中乘积为负数的最长子数组长度
        // 2.状态转移方程
        // 子数组和子序列问题的划分情况一样，都是根据长度为1和长度大于1划分情况
        // 2.1长度为1
        //    如果nums[i] > 0   f[i] = 1   g[i] = 0
        //    如果nums[i] < 0   f[i] = 0   g[i] = 1
        // 2.2长度大于1
        //    如果nums[i] > 0   f[i] = f[i-1] + 1              g[i] = g[i-1] == 0?0:g[i-1]+1
        //    如果nums[i] < 0   f[i] = g[i-1] == 0?0:g[i-1]+1  g[i] = f[i-1] + 1
        // 综上，合并状态转移方程
        //                nums[i] > 0          nums[i] < 0
        // f[i] =    f[i-1] + 1               g[i-1] == 0?0:g[i-1]+1
        // g[i] =    g[i-1] == 0?0:g[i-1]+1   f[i-1] + 1
        // 3.初始化
        // 出现了i-1 考虑第一个位置，新增一个节点
        // 初始化为0即可，不会影响后续结果
        // 4.填表顺序
        // 从左到右
        // 5.返回值
        // 遍历f表，求最大值

        int n = nums.length;
        int[] f = new int[n + 1];
        int[] g = new int[n + 1];
        int ret = 0;
        for (int i = 1; i <= n;i++) {
            // 判断
            if (nums[i - 1] > 0) {
                f[i] = f[i-1]+1;
                g[i] = g[i-1] == 0?0:g[i-1] + 1;
            } else if (nums[i-1] < 0) {
                f[i] = g[i-1] == 0?0:g[i-1] + 1;
                g[i] = f[i-1] + 1;
            }
            ret = Math.max(ret,f[i]);
        }
        return ret;
    }
}
