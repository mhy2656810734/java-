class Different{
    public int numDistinct(String s, String t) {
        // 1.状态表示
        // dp[i][j]表示s字符串[0,j]区间的所有子序列中，t字符串[0,i]区间出现的次数
        // 2.状态转移方程
        // 根据s的子序列最后一个位置包不包含s[j]来划分
        // 2.1如果包含s[j]（所有子序列都是以s[j]结尾的）
        // 并且此时s[j] == t[i]  
        // 去掉最后的s[j] 和 t[i]，s字符串[0,j-1]区间的所有子序列中，t字符串[0,i-1]区间出现的次数
        // dp[i][j] = dp[i-1][j-1];
        // 2.2如果不包含s[j]
        // dp[i][j] = dp[i][j-1]
        // 二者求和即可
        // dp[i][j] = dp[i-1][j-1]+dp[i][j-1];
        // 3.初始化
        // 状态转移方程出现了i-1 和 j-1 考虑第一行和第一列是否越界
        // 可以多加一行和一列 进行初始化
        // 对第一行初始化:dp[0][j] = 1  t字符串是一个空串，那么s的子序列一定有这个空串
        // 对第一列初始化:dp[i][0] = 0  s是一个空串，那么s的子序列一定不包含t
        // dp[0][0] =1,都是空串
        // 4.填表顺序
        // dp[i][j] 依赖于i-1和j-1 因此，从上往下填，从左到右填
        // 5.返回值
        // dp[n][m]

        // 创建dp表
        int n = s.length();
        int m = t.length();
        s = " "+s;
        t = " "+t;
        int[][] dp = new int[m+1][n+1];
        // 初始化
        for (int j = 0;j <= n;j++) {
            dp[0][j] = 1;
        }
        // 填表
        for (int i = 1; i <= m;i++) {
            for (int j = 1; j <= n;j++) {
                 dp[i][j] = dp[i][j-1];
                // 当前s的子序列是不是以s[j]结尾也就是s[j] == t[i]
                if (s.charAt(j) == t.charAt(i)) {
                    dp[i][j] += dp[i-1][j-1];
                }
               
            }
        }
        return dp[m][n];
    }
}
